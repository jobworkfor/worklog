# linux系统下的ioctl函数
      
## 一、 什么是ioctl。 
ioctl是设备驱动程序中对设备的I/O通道进行管理的函数。所谓对I/O通道进行管理，就是对设备的一些特性进行控制，例如串口的传输波特率、马达的转速等等。它的调用个数如下：

    int ioctl(int fd, ind cmd, …)； 

其中：
* `fd` - 就是用户程序打开设备时使用open函数返回的文件标示符，
* `cmd` - 就是用户程序对设备的控制命令，
* `...` - 那是一些补充参数，一般最多一个，有或没有是和cmd的意义相关的。 

ioctl函数是文件结构中的一个属性分量，就是说如果你的驱动程序提供了对ioctl的支持，用户就可以在用户程序中使用ioctl函数控制设备的I/O通道。 

## 二、 ioctl的必要性 
如果不用ioctl的话，也可以实现对设备I/O通道的控制，但那就是蛮拧了。例如，我们可以在驱动程序中实现write的时候检查一下是否有特殊约定的数据流通过，如果有的话，那么后面就跟着控制命令（一般在socket编程中常常这样做）。但是如果这样做的话，会导致代码分工不明，程序结构混乱，程序员自己也会头昏眼花的。 

所以，我们就使用ioctl来实现控制的功能。要记住，用户程序所作的只是通过命令码告诉驱动程序它想做什么，至于怎么解释这些命令和怎么实现这些命令，这都是驱动程序要做的事情。 

## 三、 ioctl如何实现 
《Linux设备驱动程序》这本书已经说的非常清楚了，但是得花一些时间来看。 

在驱动程序中实现的ioctl函数体内，实际上是有一个switch{case}结构，每一个case对应一个命令码，做出一些相应的操作。怎么实现这些操作，这是每一个程序员自己的事情，因为设备都是特定的，这里也没法说。关键在于怎么样组织命令码，因为在ioctl中命令码是唯一联系用户程序命令和驱动程序支持的途径。 

命令码的组织是有一些讲究的，因为我们一定要做到命令和设备是一一对应的，这样才不会将正确的命令发给错误的设备，或者是把错误的命令发给正确的设备，或者是把错误的命令发给错误的设备。这些错误都会导致不可预料的事情发生，而当程序员发现了这些奇怪的事情的时候，再来调试程序查找错误，那将是非常困难的事情。 

所以在Linux核心中是这样定义一个命令码的： 

| 设备类型  | 序列号    | 方向      | 数据尺寸  |
| -------- | -------- | -------- | -------- |
| 8 bit    | 8 bit    | 2 bit    | 8~14 bit |


这样一来，一个命令就变成了一个整数形式的命令码。但是命令码非常的不直观，所以Linux Kernel中提供了一些宏，这些宏可根据便于理解的字符串生成命令码，或者是从命令码得到一些用户可以理解的字符串以标明这个命令对应的设备类型、设备序列号、数据传送方向和数据传输尺寸。

这些宏我就不在这里解释了，具体的形式请读者察看Linux核心源代码中的和，文件里给除了这些宏完整的定义。这里我只多说一个地方，那就是"`幻数`"。 幻数是一个字母，数据长度也是8，所以就用一个特定的字母来标明设备类型，这和用一个数字是一样的，只是更加利于记忆和理解。就是这样，再没有更复杂的了。 更多的说了也没有，读者还是看一看源代码吧，推荐各位阅读《Linux 设备驱动程序》所带源代码中的short一例，因为它比较短小，功能比较简单，可以看明白ioctl的功能和细节。 

## 四、 cmd参数如何得出 
这里确实要说一说，cmd参数在用户程序端由一些宏根据设备类型、序列号、传送方向、数据尺寸等生成，这个整数通过系统调用传递到内核中的驱动程序，再由驱动程序使用解码宏从这个整数中得到设备的类型、序列号、传送方向、数据尺寸等信息，然后通过switch{case}结构进行相应的操作。 

要透彻理解，只能是通过阅读源代码，Cmd参数的组织还是比较复杂的，我认为要搞熟它还是得花不少时间的，但是这是值得的，驱动程序中最难的是对`中断`的理解。 

## 五、 小结 
ioctl其实没有什么很难的东西需要理解，关键是理解cmd命令码是怎么在用户程序里生成并在驱动程序里解析的，程序员最主要的工作量在switch{case}结构中，因为对设备的I/O控制都是通过这一部分的代码实现的。 

## 参考资料： 
1．《Linux 设备驱动程序》，鲁宾尼著，中国电力出版社。

Errors
----------------------------------------------------------------------------------------------------

### Error: could not insert module xxx.ko: Device or resource busy,

解决方法：
在文本界面输入`$cat /proc/devices`查看你的驱动的进程号是否和MAJOR冲突，如果冲突，修改MAJOR后重新验证。