# 深入分析Linux内核源码

多进程编程

* 进程组成
* 进程控制
* 进程间的通信机制


进程组成
* 何谓进程？
* 进程和程序的区别
* 进程的特性

何谓进程？
* 定义
    * 由代码段（text）、用户数据段（user segment）以及系统数据段（system segment）共同组成的一个动态执行环境
* 代码段可共享
* 用户数据段存放全局变量
* 系统数据段为进程的管理控制信息

进程和程序的区别
* 程序
    * 静态对象，纯粹的数据。编译后形成的可执行代码
    * 由代码段、数据段、BSS段等组成，是进程的一部分
* 进程
    * 程序的动态实例
    * 同一个程序可以有多个动态实例，多份拷贝

进程的特性
* 进程的状态
* 根据OS的调度处在不同的状态
* 进程的地址空间
* 用户空间
* 内核空间
* 独立栈

进程控制
* 父子进程
* fork
* Exec
* system
* 孤儿进程
* 僵尸进程

父子进程
* 亲缘关系
* 描述了系统进程创建的关系
* 祖先进程
* Linuxrc启动脚本
* /sbin/init
* 1号进程
* ps -ef

fork
* 功能
* 创建一个子进程
* Fork的返回值是父子进程的分岔点
* 对于父进程，返回值为子进程的pid
* 子进程，返回值0
* Fork产生的父子进程的关系
* 共享代码段
* 拷贝数据段和堆栈段
* 子进程继承父进程的所有资源
* 只有在数据段发生变化时才从物理上进行分离

exec
* 功能
* 改变当前进程的行为，替换为另一个进程
* exec产生的进程与原进程的关系
* 进程id不变，只留下躯壳
* 更新代码段，创建新的数据段和堆栈

system
* 功能
* 在父进程里面启动一个新的命令，并等待该命令执行完成
* 流程
* 函数先调用fork()
* 然后再调用exec()来执行用户的登录shell，通过它来查找可执行文件的命令并分析参数
* wait()函数族之一来等待子进程的结束

孤儿进程
* 定义
* 父进程先于子进程消亡，子进程即变为孤儿进程
* 解决办法
* 对系统无影响
* 孤儿进程将被init进程(进程号为1)所收养

僵尸进程
* 定义
* 子进程消亡时，父进程未回收task_struct资源，只剩下空壳，故为僵尸
* 原因
* 子进程结束后向父进程发出SIGCHLD信号，父进程忽略了它
* 父进程没有调用wait()或waitpid()函数来等待子进程的结束
* 解决方案
* 父进程可以通过wait系列的系统调用（如wait4、waitid）来等待某个或某些子进程的退出，并获取它的退出信息
* 杀死父进程可以让init进程回收僵尸进程的资源

进程间的通信机制
* 进程间的约束关系
* 通信机制的来源
* 通信机制的类型

进程间的约束关系
* 同步
* 指系统中一些进程需要相互合作，共同完成一项任务
* 互斥
* 由于各进程要求共享资源，但某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性
* 临界区
* 访问共享资源的代码
* 死锁
* 指多个进程互不相让，都得不到足够的资源
* 各进程按照相同的顺序获取互斥资源可以防止死锁


通信机制的来源
* Unix IPC 
* 管道、FIFO、信号
* System V IPC 
* 消息队列、信号灯、共享内存
* Posix IPC 
* 消息队列、信号灯、共享内存
* socket 

通信机制的类型
* 管道pipe
* 管道FIFO
* 共享内存
* 消息队列
* 信号灯
* 信号
* socket

管道pipe
* 特点
* 是一种单向的数据流，一个进程写入数据另外一个进程读取数据，典型的生产者消费者模型
* 基于文件系统，但是其仅存在于内存中，无文件实体
* 在最后一个访问管道的进程终止后，管道就被自动删除
* 适用场合
* 具有亲缘关系的进程
* 单处理器

管道FIFO
* 特点
* 类似普通文件，存在文件实体
* 不支持lseek文件定位操作
* Mkfifo命令或者函数建立
* 可以使用路径来指示FIFO
* 严格的先进先出，从开始处返回数据，写入时总是将数据添加到末尾
* 适用场合
* 任意进程间的通信
* 单处理器

共享内存
* 特点
* 内核的专用内存区
* 需要访问的进程将其映射到私有地址空间
* 多进程直接读取内存，无需拷贝数据
* 因为共享，所以需要互斥，通常和信号灯配合使用
* 可以通过使用shmctl函数设置共享存储内存的某些标志位如SHM_LOCK、SHM_UNLOCK等来实现
* 适用场合
* 任意进程间的快速通信
* 单处理器

消息队列
* 特点
* 一个消息列表，用户可以添加及读取消息
* 类似FIFO，但可以根据msg类型实现随机读取
* 可根据消息类型实现不同的功能
* 操作类型包括创建、发送、接收及控制
* 消息存在于内核中，由队列id标识
* 适用场合
* 任意进程间的通信
* 单处理器

信号灯
* 特点
* 实现资源的互斥访问
* 无法携带其他更多的辅助信息
* 适用场合
* 任意进程间的互斥通信
* 单处理器

信号
* 特点
* 是一种异步机制，是软件层次上对中断的一种模拟
* 每一个进程可以自定义对信号的处理流程，甚至改变信号的行为
* 忽略、捕捉、默认行为
* Sigkill和sigstop不能忽略
* 适用场合
* 任意进程间的通信，通常用于内核向进程发送消息
* 单处理器

socket
* 特点
* 基于套接字的编程，利用TCP/IP协议栈
* 可以实现任意类型的通信，消息可以自由定义
* 适用场合
* 任意进程间的通信
* 单处理器及多机

多线程编程
* 线程的特点
* Linux的线程模型
* 线程的通信机制

进程和用户线程的区别
* 线程
* 进程的子集，由线程库调度，程序执行的最小单位
* 多线程模型设计使程序更简洁明了
* 更好的支持SMP以及减小上下文切换开销
* 进程
* 资源分配和管理的最小单位
* 具备独立的地址空间
* 创建销毁慢
* 内核调度的基本单位
* 上下文切换开销大

进程和用户及内核线程的区别
* 进程
* 内核调度的基本单位
* 包括用户空间和内核空间两部分
* 用户线程
* 线程库调度，只有用户空间
* 内核线程
* 内核调度，只有内核空间
* 其他和进程一样

Linux的线程模型
* 一对多模型

线程间的通信机制
* Thread-specific Data 
* 仅供本线程使用的全局变量
* 互斥锁
* pthread_mutex_t
* 实现线程间的互斥访问
* 条件变量
* pthread_cond_t
* 利用共享的全局变量进行同步
* 需要和线程锁配合使用以防止竞态
* 信号灯
* 可以有多个值，主要用于同步操作
* 即使没有人等待灯，释放灯也是有意义的


网络编程
* 网络编程的基本流程
* 并发服务器的设计模型

网络编程的基本流程
* TCP 
* 演示
* UDP
* 演示

并发服务器的设计模型
* 多进程
* 每个进程服务一个客户端。优势是有各自独立的地址空间，可靠性高，但进程调度开销大，无法资源共享，进程间通信机制复杂
* 多线程
* 每个线程服务一个客户端。优势是开销小，通信机制简单，可共享内存。但共享地址空间，可靠性低，一个服务器出现问题时可能导致系统崩溃，同时全局共享可能带来竞争，共享资源需要互斥，对编程要求高

并发服务器的设计模型
* 单进程select
* 占有的进程及线程资源少，通信机制简单。但监听服务器及各个子服务器揉和在一起，程序结构复杂不清晰，编程麻烦

应用程序的调试技巧
* 错误打印
* 内存泄露检查
* Core dump
* 自动调用GDB
* 自动显示调用栈

错误打印
* Abort
* 异常终止程序，不做清除工作
* Exit
* 正常终结目前进程的执行，并把参数 status 返回给父进程
* Atexit
* 注册程序正常终止时要被调用的函数
* Strerror
* 返回错误原因的描述字符串
* perror
* 返回错误原因的描述字符串，并把它输出到标准错误输出流

错误打印
* __FILE__
* Log对应的源文件名
* __LINE__
* Log对应的行号
* __FUNCTION__
* Log对应的函数名

内存泄露检查
* 功能
* 检查是否有不对称的动态内存申请释放以及指针越界操作
* tools
* Mtrace
* memwatch

Core dump
* 功能
* 当出现非法地址访问时会出现segmentatio* fault，使能core dump后会自动记录程序崩溃时的内存现场至log文件
* 可以利用gdb工具读取该log文件获得程序崩溃的位置及原因
* tools
* sysctl -w “kernel.core_pattern=/xx/%e-core.%p”设置产生的core dump文件的路径及命名规则
* gdb EXECUTALBE_FILE CORE_FILE分析core dump文件
* bt 打印出错的栈调用信息

自动调用GDB
* 功能
* 当出现非法地址访问时会出现segmentatio* fault，内核会向对应的进程发送SIGSEGV，其默认行为是打印segmentatio* fault
* 可以改变SIGSEGV信号的默认行为，在处理函数里自动调用gdb启动调试
* tools
* Getpid获得当前运行进程的pid号
* 根据/proc/pidxxx/cmdline获得gdb启动时的参数
* 获得SIGSEGV信号自动调用“gdb axxx”
* bt 打印出错的栈调用信息

自动显示调用栈
* 功能
* 嵌入式平台上一般没有gdb等调试工具，另外单步调试对于多进程多线程程序的调试不方便
* 当出现非法地址访问时会出现segmentatio* fault，可以改变SIGSEGV信号的默认行为，在处理函数里自动打印栈信息，模拟bt命令
* tools
* Backtrace获得当前函数调用的级别
* backtrace_symbols获得部分符号化的调用栈
* Objdump反汇编程序，分析栈中返回地址对应的上一条指令地址

## Linux pid，tgid关系

一、进程PID和线程PID

线程是轻量级的进程，有自己的PID，只不过共享进程的一些数据，比如说堆。

二、tgid

thread group id。对于同一进程中的所有线程，tgid都是一致的，为该进程的进程ID。

````bash
                USER VIEW
 <-- PID 43 --> <----------------- PID 42 ----------------->
                     +---------+
                     | process |
                    _| pid=42  |_
                  _/ | tgid=42 | \_ (new thread) _
       _ (fork) _/   +---------+                  \
      /                                        +---------+
+---------+                                    | process |
| process |                                    | pid=44  |
| pid=43  |                                    | tgid=42 |
| tgid=43 |                                    +---------+
+---------+
 <-- PID 43 --> <--------- PID 42 --------> <--- PID 44 --->
                KERNEL VIEW
````

在这里你可以清晰的看到，创建一个新的进程会给一个新的PID和TGID，并且2个值相同，当创建一个新的线程的时候，会给你一个新的PID，并且TGID和之前开始的进程一致。

